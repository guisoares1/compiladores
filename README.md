# Description
This project aims to simulate the structures of a compiler by implementing lexical, semantic, and syntactic analysis.
The language description is inside the descricao folder.

# What is a compiler?
A compiler is a program that translates a source code written in a programming language into an object code in another language, usually of low level. It consists of two main parts: the front-end and the back-end. The front-end is responsible for analyzing the source code and producing an intermediate representation of the program, which is easier to manipulate and optimize. The back-end is responsible for generating the object code from the intermediate representation, taking into account the characteristics of the target platform.
## Front-end

The front-end is divided into three stages: lexical analysis, syntactic analysis and semantic analysis.

- Lexical analysis identifies the tokens of the program, that is, the basic units of meaning, such as keywords, identifiers, numbers and symbols. For example, in the expression `*a* = *b* + *c*;`, the tokens are `*a*`, `=`, `*b*`, `+`, `*c*` and `;`.
- Syntactic analysis checks whether the sequence of tokens is in accordance with the grammar of the language, that is, the rules that define the structure of the programs. For example, in the expression `*a* = *b* + *c*;`, the rule that defines an assignment is `<variable> = <expression>;`.
- Semantic analysis checks whether the semantic rules of the language are being followed, that is, the rules that define the meaning of the programs. For example, in the expression `*a* = *b* + *c*;`, the rules that define the types of the variables and the operations must be respected.

## Back-end

The back-end is divided into two stages: optimization and code generation.

- Optimization aims to improve the performance of the program generated by the compiler, eliminating redundancies, simplifying expressions and taking advantage of resources from the target platform. For example, in the expression `*a* = *b* + *c* + *d*;`, a possible optimization is to calculate beforehand the value of `*b* + *c*` and store it in a register.
- Code generation aims to produce the object code that will be executed by the computer, respecting calling conventions, memory allocation and instructions from the target platform. For example, in the expression `*a* = *b* + *c*;`, a possible code generation in assembly language would be:

```assembly
mov eax, [b] ; move the value of b to the register eax
add eax, [c] ; add the value of c to the register eax
mov [a], eax ; move the value of the register eax to the variable a
```
# Project Structure
- lexico.py: Responsible for returning the next token from the code.
- AnalisadorSintatico.py: Responsible for performing code analysis and returning whether it is valid or not.
- token.py: Entity that stores the language structure.
- TabelaSimbolos.py: Responsible for constructing the symbol table.
- preditivo.xlsx: Table that guides the compiler on the language rules.
- producoes.xlsx: Table that guides the compiler on the production tree of a non-terminal.

  ![alt text](https://github.com/guisoares1/Imagens/blob/main/estrutura-compilador.png)
  
# How to Use
The project includes the exemplo.txt file, where the code to be analyzed is placed.

With the Codigo directory open, execute the following command:
```ps
python .\AnalisadorSintatico.py
```
# Tasks
- [X] Lexical Analysis
- [x] Syntactic Analysis 
- [x] Predictive Table
- [X] Production Table
- [ ] Semantic Analysis

  
